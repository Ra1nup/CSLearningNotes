### 🔧 构造函数与析构函数  
- **构造函数**  
  对象**创建时**自动执行，用于初始化成员。  
  - 特点：  
    - 与类同名，无返回类型  
    - 支持重载（多个不同参数的构造函数）  
    - 默认提供无参构造（除非用户自定义构造函数）  
  ```cpp
  class Book {
  public:
      Book() {  // 无参构造
          pages = 300;
      }
      Book(int p) {  // 有参构造
          pages = p;
      }
  private:
      int pages;
  };
  ```

- **析构函数**  
  对象**销毁时**自动执行，用于资源清理。  
  - 特点：  
    - 名为 `~类名`，无参数无返回值  
    - 不可重载（唯一性）  
    - 默认提供空实现析构函数  
  ```cpp
  class Book {
  public:
      ~Book() {  // 析构函数
          cout << "释放资源" << endl;
      }
  };
  ```

---

### 🧩 构造函数的分类与调用  
- **分类**  
  - 按参数：无参构造、有参构造  
  - 按类型：普通构造、拷贝构造  
    ```cpp
    class Car {
    public:
        Car();                // 无参构造
        Car(string model);    // 有参构造
        Car(const Car& c);    // 拷贝构造
    };
    ```

- **调用方式**  
  1. **显式调用**  
     ```cpp
     Car c1;                 // 无参构造
     Car c2("Tesla");        // 有参构造
     Car c3(c2);             // 拷贝构造
     ```
  2. **隐式转换**  
     ```cpp
     Car c4 = "BMW";         // 等价 Car c4("BMW")
     Car c5 = c4;            // 等价 Car c5(c4)
     ```

![[Pasted image 20250804004922.png]]

---

### 📨 拷贝构造函数调用时机  
- **定义**  
  `类名(const 类名& 源对象)`  
  ```cpp
  Car(const Car& c) {
      model = c.model;  // 复制成员值
  }
  ```
- **调用场景**  
  1. 用现有对象初始化新对象  
     ```cpp
     Car c1;
     Car c2(c1);  // 触发拷贝构造
     ```
  2. 值传递对象给函数  
     ```cpp
     void repairCar(Car c) { ... }  // 传参时调用拷贝
     ```
  3. 值方式返回局部对象  
     ```cpp
     Car createCar() {
         Car c;
         return c;  // 返回时调用拷贝构造
     }
     ```

---

### 📜 构造函数调用规则  
编译器自动提供以下函数（用户未定义时）：
1. 无参构造函数（空函数体）  
2. 拷贝构造函数（逐成员复制）  
3. 析构函数（空函数体）  

⚠️ **重要规则**：  
- 用户**定义有参构造** → 编译器**不再生成无参构造**  
- 用户**定义拷贝构造** → 编译器**不再生成任何默认构造**  

---

### 🔗 深拷贝与浅拷贝  
- **浅拷贝**  
  - 默认行为：直接复制指针地址  
  - 风险：多个对象共享内存导致重复释放  
    ```cpp
    class Shallow {
    public:
        int* buffer;
        Shallow(int size) {
            buffer = new int[size];
        }
        // 默认拷贝：Shallow(const Shallow& s) { buffer = s.buffer; }
    };
    ```

- **深拷贝**  
  - 手动实现：为指针成员**分配独立内存**  
  - 解决内存冲突问题  
    ```cpp
    class Deep {
    public:
        int* buffer;
        Deep(int size) {
            buffer = new int[size];
        }
        // 深拷贝构造
        Deep(const Deep& d) {
            buffer = new int[size];  
            copy(d.buffer, d.buffer + size, buffer);
        }
        ~Deep() { delete[] buffer; }
    };
    ```

---

### 🚀 初始化列表  
- **作用**  
  高效初始化成员（尤其const/引用成员）  
- **语法**：  
  `构造函数(): 成员1(值1), 成员2(值2), ... {}`  
  ```cpp
  class Circle {
  public:
      Circle(double r) : radius(r), area(3.14*r*r) { 
          // 初始化完成后执行此代码
      }
  private:
      const double radius;  // const成员必须列表初始化
      double area;
  };
  ```
- **特点**：  
  - 执行顺序**由成员声明顺序决定**  
  - 比构造函数体内赋值效率更高  

---

### 🧱 类对象作为类成员  
- 当类A包含类B成员时：  
  - 构造顺序：**B成员 → A自身**  
  - 析构顺序：**A自身 → B成员**  
- **示例**：  
  ```cpp
  class Engine {
  public:
      Engine(string type) : model(type) {}
  private:
      string model;
  };

  class Vehicle {
  public:
      Vehicle(string vName, string eType) 
          : name(vName), engine(eType) {}  // 初始化engine对象
  private:
      string name;
      Engine engine;  // 类对象成员
  };
  ```

---

### 🌐 静态成员  
- **静态成员变量**  
  - 所有对象共享同一数据  
  - 必须在类外初始化  
    ```cpp
    class User {
    public:
        static int totalUsers;  // 声明
    };
    int User::totalUsers = 0;   // 类外初始化
    ```

- **静态成员函数**  
  - 仅能访问静态成员  
  - 通过类名直接调用  
    ```cpp
    class User {
    public:
        static void showTotal() {
            cout << totalUsers;  // 仅访问静态成员
        }
    };
    User::showTotal();  // 无需对象实例
    ```

- **特点**：  
  - 属于类而非对象  
  - 静态函数无 `this` 指针  

--- 

💡 核心要点总结：  
1. 构造/析构函数管理对象**生命周期**  
2. 深拷贝解决**指针成员**的内存共享问题  
3. 初始化列表优化**const/引用成员**初始化  
4. 静态成员实现**类级别**的数据共享